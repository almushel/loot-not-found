<html>

<head>
	<style>
		* {
			background-color: #202020;
			margin: 0;
			padding: 0;
		}
	</style>
	<script src='physics.js'></script>
	<script src='objects.js'></script>
	<script src='collision.js'></script>
	<script src='level.js'></script>
	<script src='camera.js'></script>
	<script src='ui.js'></script>
	<script src='input.js'></script>
	<script>

		let player = {
			_hp: 100,
			_loot: 0,
			color: '#4060C0',
			size: 16,
			position: new Vector2(GRID_SIZE * 2, GRID_SIZE * 2),
			rotation: new Vector2(0, 1),
			velocity: new Vector2(0, 0),
			acceleration: .4,
			friction: 0.96,
			collider: { type: 'circle', physics: 'dynamic',
						get radius() {return player.size}, get x() {return player.x}, get y() { return player.y},
						},
			draw() {
				ctx.fillStyle = this.isDead ? '#203060' : this.color;
				ctx.beginPath()
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
				ctx.fill();
			},
			die() {
				this.isDead = true
				let dIndex = tileAtCoords(this.position.x, this.position.y);
				currentLevel.spawnTile(0, dIndex, BLOOD);
			},
			get x() { return this.position.x },
			get y() { return this.position.y },
			get hp() {return this._hp},
			set hp(val) {
				this._hp = clamp(val, 0, 100);
				if (this._hp == 0 && !this.isDead) this.die();
			},
			get loot() { return this._loot; },
			set loot(val) {this._loot = clamp(val, 0, 404); },
		}

		this.onload = () => {
			canvas = document.getElementById('canvas');
			ctx = canvas.getContext('2d');

			window.addEventListener('resize', resizeCanvas);
			window.addEventListener('orientationchange', resizeCanvas);
			resizeCanvas()

			currentLevel = generateLevel(9, 9);
			let centerTile = tileAtCoords(currentLevel.width/2 * GRID_SIZE, currentLevel.height/2 * GRID_SIZE);
			currentLevel.spawnTile(1, centerTile - 1, FIRE);
			currentLevel.spawnTile(0, centerTile + 11, WATER);
			currentLevel.spawnTile(0, centerTile - 11, OIL);
			currentLevel.objects.push(new LootPiece(GRID_SIZE * 50, GRID_SIZE * 50));
			
			player.position.x = currentLevel.width/2 * GRID_SIZE - (GRID_SIZE * 24);
			player.position.y = currentLevel.height/2 * GRID_SIZE + GRID_SIZE;

			setInterval(update, 1000 / 60);
		}

		function update() {
			physicsUpdate();
			updateCamera();
			draw();
		}

		function draw() {
			ctx.clearRect(0, 0, w, h);
			ctx.translate(-panX, -panY);
			currentLevel.draw(0)
			for (object of currentLevel.objects) {
				object.draw();
			}
			player.draw();
			currentLevel.draw(1);
			ctx.translate(panX, panY);
			drawUI();
		}

		function shuffle(array) {
			let currentIndex = array.length, randomIndex, currentElement;

			while (currentIndex) {
				randomIndex = Math.floor(Math.random() * currentIndex--);

				currentElement = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = currentElement;
			}

			return array;
		}

		function clamp (value, min, max) {
			return Math.min(max, Math.max(value, min));
		}

	</script>
</head>

<body>
	<canvas id="canvas"></canvas>
</body>

</html>