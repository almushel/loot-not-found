<html>

<head>
	<style>
		* {
			background-color: #202020;
			margin: 0;
			padding: 0;
		}
	</style>
	<script src='globals.js'></script>
	<script src='physics.js'></script>
	<script src='particles.js'></script>
	<script src='objects.js'></script>
	<script src='collision.js'></script>
	<script src='level.js'></script>
	<script src='camera.js'></script>
	<script src='ui.js'></script>
	<script src='input.js'></script>
	<script>
		let player = {
			_hp: 100,
			_loot: 0,
			color: '#4060C0',
			size: 16,
			held: null,
			position: new Vector2(TILE_SIZE * 2, TILE_SIZE * 2),
			rotation: new Vector2(0, 1),
			velocity: new Vector2(0, 0),
			acceleration: .4,
			friction: 0.96,
			collider: {
				type: 'circle', physics: 'dynamic',
				get radius() { return player.size }, get x() { return player.x }, get y() { return player.y },
			},
			draw() {
				let color = this.isDead ? '#203060' : this.color;
				let tileColors = nearTileColors(1, this.x, this.y);
				let emptyTiles = 9 - tileColors.length;
				if (tileColors.length) color = averageHexColors(tileColors.concat(new Array(tileColors.length + emptyTiles).fill(color)));

				ctx.shadowColor = '#000000';
				ctx.shadowBlur = 2;
				
				if (this.held) this.held.drawHeld();

				ctx.fillStyle = color;

				ctx.beginPath()
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
				ctx.fill();

				ctx.shadowBlur = 0;

				ctx.strokeStyle = '#ffffff';
				ctx.beginPath();
				ctx.moveTo(this.x, this.y);
				ctx.lineTo(this.x + this.rotation.x * this.size, this.y + this.rotation.y * this.size);
				ctx.stroke();
			},
			die() {
				this.isDead = true
				let dIndex = tileAtCoords(this.position.x, this.position.y);
				currentLevel.spawnTile(dIndex, BLOOD);
			},
			get x() { return this.position.x },
			get y() { return this.position.y },
			get hp() { return this._hp },
			set hp(val) {
				this._hp = clamp(val, 0, 100);
				if (this._hp == 0 && !this.isDead) this.die();
			},
			get loot() { return this._loot; },
			set loot(val) { this._loot = clamp(val, 0, 404); },
		}

		this.onload = () => {
			canvas = document.getElementById('canvas');
			ctx = canvas.getContext('2d');
			particles = new ParticleSystem(9 * 16 * 16);

			window.addEventListener('resize', resizeCanvas);
			window.addEventListener('orientationchange', resizeCanvas);
			resizeCanvas()

			currentLevel = generateLevel(9, 9);
			let centerTile = tileAtCoords(currentLevel.width / 2 * TILE_SIZE, currentLevel.height / 2 * TILE_SIZE);
			currentLevel.spawnTile(centerTile + 11, WATER);
			currentLevel.spawnTile(centerTile - 11, OIL);

			player.position.x = currentLevel.width / 2 * TILE_SIZE;
			player.position.y = currentLevel.height / 2 * TILE_SIZE;

			currentLevel.objects.push(new Hammer(player.x - TILE_SIZE * 4, player.y));
			currentLevel.objects.push(new FireBomb(player.x + TILE_SIZE * 4, player.y));

			setInterval(update, 1000 / 60);
		}

		function update() {
			physicsUpdate();
			updateCamera();
			draw();
		}

		function draw() {
			ctx.clearRect(0, 0, w, h);
			ctx.translate(-panX, -panY);
			currentLevel.draw();
			particles.draw();
			for (object of currentLevel.objects) {
				object.draw(object.position.x, object.position.y);
			}
			player.draw();
			ctx.translate(panX, panY);
			drawUI();
		}

		function shuffle(array) {
			let currentIndex = array.length, randomIndex, currentElement;

			while (currentIndex) {
				randomIndex = Math.floor(Math.random() * currentIndex--);

				currentElement = array[currentIndex];
				array[currentIndex] = array[randomIndex];
				array[randomIndex] = currentElement;
			}

			return array;
		}

		function clamp(value, min, max) {
			return Math.min(max, Math.max(value, min));
		}

		function lerp(start, end, weight) {
			return (1 - clamp(weight, 0, 1)) * start + clamp(weight, 0, 1) * end;
		}

		function smoothStart(weight, magnitude) {
			let sWeight = weight;
			for (let i = 0; i < magnitude; i++) {
				sWeight *= weight;
			}

			return sWeight;
		}

		function smoothStop(weight, magnitude) {
			let sWeight = 1 - weight;
			for (let i = 0; i < magnitude; i++) {
				sWeight *= (1 - weight);
			}

			return 1 - sWeight;
		}

		function nearTileColors(layer, x, y) {
			let tiles = tilesNearPosition(x, y);
			let colors = [];
			for(tile of tiles) {
				let type = currentLevel.getType(layer, tile);
				if (type > GRND) {
					colors.push(substColors[type]);
				}
			}
			return colors;
		}

		function averageHexColors(colors) {
			if (colors.length == 1) return colors[0];
			let total = [0,0,0];
			for (let color of colors) {
				total[0] += parseInt(color.slice(1, 3), 16);
				total[1] += parseInt(color.slice(3, 5), 16);
				total[2] += parseInt(color.slice(5, 7), 16);
			}

			if (total[0]) total[0] = clamp(Math.floor(total[0] / colors.length), 0, 255);
			if (total[1]) total[1] = clamp(Math.floor(total[1] / colors.length), 0, 255);
			if (total[2]) total[2] = clamp(Math.floor(total[2] / colors.length), 0, 255);

			return ('#' + total[0].toString(16) + total[1].toString(16) + total[2].toString(16));
		}

		function hexColorToInts(color) {
			let subst = [color.slice(1, 3), color.slice(3, 5), color.slice(5, 7)];

			return [parseInt(subst[0], 16), parseInt(subst[1], 16), parseInt(subst[2], 16)];
		}

		function addHexColors(color1, color2) {
			let subst1 = [color1.slice(1, 3), color1.slice(3, 5), color1.slice(5, 7)]
			let subst2 = [color2.slice(1, 3), color2.slice(3, 5), color2.slice(5, 7)]
			let sums = [];

			for (let c = 0; c < subst1.length; c++) {
				let sum = parseInt(subst1[c], 16) + parseInt(subst2[c], 16);
				sum = clamp(sum, 0, 255);
				sums.push(sum);
			}

			return ('#' + sums[0].toString(16) + sums[1].toString(16) + sums[2].toString(16));
		}

	</script>
</head>

<body>
	<canvas id="canvas"></canvas>
</body>

</html>