<html>

<head>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
	</style>
	<script>
		const GRID_SIZE = 16;
		let canvas, ctx, w, h;
		
		const tileTypes = [
			{name: 'ground', durability: Infinity, effects: new Set([2, 4, 5, 6]),},	//0 ground
			{name: 'concrete', durability: 100, effects: new Set([]),},					//1 concrete
			{name: 'wood', durability: 50, effects: new Set([0]),},						//2 wood
			{name: 'metal', durability: 100, effects: new Set([2, 3]),},				//3 metal
			{name: 'glass', durability: 25, effects: new Set([]),},						//4 glass
		];

		const tileColors = ['#204620', '#505050', 'saddlebrown', 'dimgrey', 'skyblue'];

		const effectTypes = [
			{name: 'fire', ondeath: 3,},			//0 fire
			{name: 'water'}, 		//1 water
			{name: 'electricity'},	//2 electricity
			{name: 'smoke'},  		//3 smoke
			{name: 'gas'},			//4 gas
			{name: 'steam'},		//5 steam
		];

		const effectColors = ['red', 'blue', 'yellow', '#090909', 'green', 'powderblue'];

		/*
			Element tiles:
				-1 hp per tick
				1 hp elemental damage to adjacent tiles per tick
					Only damage weak tiles (i.e. fire damages wood, but not concrete)
					Tiles inherit elemental effect at certain HP threshold (50%?)
					If adjacent tile already has elemental effect, check for interactions (electricity + water)
					If adjacent tile is empty, check for fill effect (fire produces smoke)
				
		*/

		class ElementEffect {
			constructor (type, tileIndex){
				this.type = type;
				this.tile = tileIndex;
				this.lifeTime = 300;
			}
		}
		
		
		class Vector2 {
			constructor(x, y) {
				this.x = x;
				this.y = y;
			}

			add(vector) {
				return new Vector2(this.x + vector.x, this.y + vector.y);
			}

			subtract(vector) {
				return new Vector2(this.x - vector.x, this.y - vector.y);
			}

			multiply(scalar) {
				if (scalar === 0) return new Vector2(0, 0);
				return new Vector2(this.x * scalar, this.y * scalar);
			}

			divide(scalar) {
				if (scalar === 0) return new Vector2(0, 0);
				return new Vector2(this.x / scalar, this.y / scalar);
			}

			rotate(angle) {
				let x = Math.cos(this.x) - Math.sin(this.y), y = Math.sin(this.x) + Math.cos(this.y);
				return new Vector2(x, y);
			}

			dotProduct(vector, normalized) {
				let v1 = normalized ? this : this.normalize();
				let v2 = normalized ? vector : vector.normalize();

				return v1.x * v2.x + v1.y * v2.y
			}

			normalize() {
				let magnitude = Math.hypot(this.x, this.y);

				return this.divide(magnitude);
			}

			get length() {
				return Math.hypot(this.x, this.y);
			}

			set length(scalar) {
				if (scalar <= 0) {
					this.x = this.y = 0;
				} else {
					let nv = this.normalize().multiply(scalar);
					this.x = nv.x;
					this.y = nv.y;
				}
			}
		}

		let player = {
			color: 'green',
			size: 16,
			position: new Vector2(GRID_SIZE * 2, GRID_SIZE * 2),
			rotation: new Vector2(0, 1),
			velocity: new Vector2(0, 0),
			acceleration: .4,
			friction: 0.96,
			collider: { type: 'circle', physics: 'dynamic',
						get radius() {return player.size}, get x() {return player.x}, get y() { return player.y},
						},
			draw() {
				ctx.fillStyle = this.color;
				ctx.beginPath()
				ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
				ctx.fill();
			},
			get x() { return this.position.x },
			get y() { return this.position.y },
		}



		class GameLevel {
			_grid = [];
			_tileHP = [];
			effects = [];
			width = 0;
			height = 0;
		
			get grid() {return this._grid;}
			set grid(newGrid) {
				this._grid = newGrid;
				this._tileHP.length = this._grid.length;
				this._tileHP.fill(100);
			}
		}
		
		//collider types: circle, rect, poly

		function generateLevel(width, height) {
			let newGrid = [];
			newGrid.length = width * height;
			newGrid.fill(0);
			let index = 0;
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					if (y < 4 || y > height - 4 || x < 4 || x > width - 4);
					else if (Math.abs((height/2) - y) <= 5) newGrid[index] = 2;
					else if (x % 8 == 0) newGrid[index] = 1;
					else newGrid[index] = 2;
					index++;
				}
			}
			
			console.log(newGrid[843]);
			let newLevel = new GameLevel();
			newLevel.width = width;
			newLevel.height = height;
			newLevel.grid = newGrid;

			return newLevel;
		}

		function checkCollision(col1, col2) {
			let collision = {};
			if (col1.type == 'circle') {
				switch(col2.type) {
					case 'circle':
						collision = circleOverlap(col1, col2);
						break;
					case 'rect':
						collision = circleRectOverlap(col1, col2);
						break;
					default:
						break;
				}
			} else if (col1.type = 'rect') {
				switch(col2.type) {
					case 'circle':
						collision = circleRectOverlap(col1, col2);
						break;
					case 'rect':
						collision = aabbOverlap(col1, col2);
						break;
					default:
						break;
				}
			}

			return collision;
		}

		function circleOverlap(circle1, circle2) {
			let distX = circle1.x - circle2.x;
			let distY = circle1.y - circle2.y;
			let dist = Math.hypot(distX, distY);
			let width = circle1.radius + circle2.radius;
			if (dist <= width) {
				return {hit: true, overlap: {x: distX, y: distY} }
			}

			return {hit: false, overlap: 0}
		}

		function circleRectOverlap(circle, rect) {
			let dist = new Vector2(circle.x - rect.x, circle.y - rect.y);
			let ang = Math.atan2(dist.y, dist.x) + Math.PI;
			let width = rect.width/2 + Math.abs(Math.cos(ang) * circle.radius),
				height = rect.height/2 + Math.abs(Math.sin(ang) * circle.radius);

			if (Math.abs(dist.x) <= width && Math.abs(dist.y) <= height) {
				return {hit: true, overlap: new Vector2(width - Math.abs(dist.x), height - Math.abs(dist.y)) };
			}

			return {hit: false, overlap: 0};
		}

		function aabbOverlap(rect1, rect2) {
			let distX = rect1.x - rect2.x;
			let distY = rect1.y - rect2.y;

			if (distX <= (rect1.width + rect2.width) / 2 && distY <= (rect1.height + rect2.height) / 2) {
				return {hit: true, overlap: {x: distX, y: distY} };
			}

			return {hit: false, overlap: 0};
		}

		let controls = {
			u: 0, d: 0, l: 0, r: 0, //directions
			interact: 0,//Interact with world object
			use: 0, //Use held item
		}

		this.addEventListener('keydown', (e) => {
			setControl(e.which, 1);
		})
		this.addEventListener('keyup', (e) => {
			setControl(e.which, 0);
		})

		function setControl(key, to) {
			if (key == 65 || key == 37) { controls.l = to } //a or left
			if (key == 68 || key == 39) { controls.r = to } //d or right
			if (key == 87 || key == 38) { controls.u = to } //w or up
			if (key == 83 || key == 40) { controls.d = to } //s or down
			if (key == 32) { controls.interact = 1 } //space
			if (key == 17) { controls.use = 1 } //control
		}

		this.onload = () => {
			canvas = document.getElementById('canvas');
			ctx = canvas.getContext('2d');

			canvas.width = w = window.innerWidth;
			canvas.height = h = window.innerHeight;

			window.addEventListener('resize', resizeCanvas);
			window.addEventListener('orientationchange', resizeCanvas);

			currentLevel = generateLevel(Math.floor(w / GRID_SIZE), Math.floor(h / GRID_SIZE));
			currentLevel.effects.push(
				new ElementEffect(0, Math.ceil(currentLevel.grid.length/2))
				);
			draw();
			setInterval(update, 1000 / 60);
		}

		function update() {
			physicsUpdate();
			draw();
		}

		function control() {
			let av = new Vector2(0, 0);
			if (controls.l) av.x -= 1;
			if (controls.r) av.x += 1;
			if (controls.u) av.y -= 1;
			if (controls.d) av.y += 1;

			return av.normalize();
		}

		function updateElements() {
			for (let e = currentLevel.effects.length-1; e >= 0; e--) {
				let element = currentLevel.effects[e];
				if (element.lifeTime <= 0 || currentLevel._tileHP[element.tile] <= 0)  {
					currentLevel._tileHP[element.tile] = 100;
					currentLevel.effects.splice(e, 1);
					
					let deathEffect = effectTypes[element.type].ondeath
					if (deathEffect) currentLevel.effects.push(new ElementEffect(deathEffect, element.tile));
					continue;
				}
				if (currentLevel.grid[element.tile]) {
					currentLevel._tileHP[element.tile] -= Math.random();
					if (currentLevel._tileHP[element.tile] <= 0) currentLevel.grid[element.tile] = 0;
				}

				for (let y = -1; y < 2; y++) {
					for (let x = -1; x < 2; x++) {
						let checkTile = element.tile + (currentLevel.width * y) + x;
						if (checkTile < 0 || checkTile > currentLevel.grid.length) continue;
						if (currentLevel.effects.findIndex((e) => e.tile === checkTile) < 0) {
							let tileType = currentLevel.grid[checkTile];
							if (tileTypes[tileType].effects.has(element.type) && Math.random() > 0.98) {
								currentLevel.effects.push(new ElementEffect(0, checkTile));
							}
						}
					}
				}

				element.lifeTime--;
			}
		}

		function physicsUpdate() {
			updateElements();
			let cv = control();
			player.velocity = player.velocity.add(cv.multiply(player.acceleration));
			player.position = player.position.add(player.velocity);
			player.velocity.length *= player.friction;
		
			let width = currentLevel.width, height = currentLevel.height;
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					let tileType = currentLevel.grid[y * width + x];
					if (!tileType) continue;

					let tileRect = {x: (x * GRID_SIZE) + (GRID_SIZE/2), y: (y * GRID_SIZE) + (GRID_SIZE/2), 
									type: 'rect', width: GRID_SIZE, height: GRID_SIZE};
					let collision = checkCollision(player.collider, tileRect);
					if (collision.hit) {
						let correction  = new Vector2(player.x - tileRect.x, player.y - tileRect.y);
						if (Math.abs(correction.x) > Math.abs(correction.y)) correction.y = 0;
						else correction.x = 0;

						correction = correction.normalize();
						correction.x *= collision.overlap.x;
						correction.y *= collision.overlap.y;
						player.position = player.position.add(correction);
						player.velocity = player.velocity.add(correction);
						player.velocity = player.velocity.multiply(player.friction);
					}
				}
			}
		}

		function draw() {
			ctx.fillStyle = tileColors[0];
			ctx.fillRect(0, 0, w, h);
		
			drawGrid();
			player.draw();
			drawElements();
		}

		function drawElements() {
			ctx.globalAlpha = 0.4;
			for (let effect of currentLevel.effects) {
				ctx.fillStyle = effectColors[effect.type];
				let x = effect.tile % currentLevel.width;
				let y = (effect.tile - x) / currentLevel.width;
				ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
			}
			ctx.globalAlpha = 1;
		}

		function drawGrid() {
			let width = currentLevel.width, height = currentLevel.height;
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					let tileType = currentLevel.grid[y * width + x];
					ctx.fillStyle = tileColors[tileType];		
					if (tileType) ctx.fillRect(x * GRID_SIZE,y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
				}
			}
		}

		function resizeCanvas(e) {
			canvas.width = w = window.innerWidth;
			canvas.height = h = window.innerHeight;
			draw();
		}

	</script>
</head>

<body>
	<canvas id="canvas"></canvas>
</body>

</html>